# Guía Completa: Tipos de Datos y Operaciones en C

## Introducción

El lenguaje de programación C es un lenguaje de tipado estático de nivel medio que proporciona control directo sobre los recursos del sistema. Comprender los tipos de datos y las operaciones básicas es fundamental para escribir programas C eficientes y correctos. Esta guía cubre todos los aspectos esenciales de la manipulación de datos en C.

## Capítulo 1: Tipos de Datos en C

### 1.1 Tipos Enteros

C proporciona varios tipos enteros con diferentes tamaños y rangos:

#### char
- **Tamaño**: 1 byte (8 bits)
- **Rango**: -128 a 127 (con signo) o 0 a 255 (sin signo)
- **Uso principal**: Almacenamiento de caracteres y enteros pequeños
- **Eficiente en memoria**: Ideal para almacenar caracteres ASCII

```c
char letra = 'A';
char valor_ascii = 65;  // Equivalente a 'A'
unsigned char valor_byte = 255;
```

#### short (short int)
- **Tamaño**: 2 bytes (16 bits)
- **Rango**: -32,768 a 32,767
- **Caso de uso**: Enteros pequeños cuando la conservación de memoria es importante

```c
short año = 2024;
short temperatura = -15;
```

#### int
- **Tamaño**: Típicamente 4 bytes (32 bits) en la mayoría de sistemas modernos
- **Rango**: -2,147,483,648 a 2,147,483,647
- **Uso principal**: Aritmética entera de propósito general

```c
int edad = 25;
int poblacion = 1000000;
```

#### long (long int)
- **Tamaño**: Al menos 4 bytes (a menudo 8 bytes en sistemas de 64 bits)
- **Rango**: Dependiente del sistema
- **Caso de uso**: Enteros grandes más allá del rango de int

```c
long distancia = 1000000000L;  // Nota el sufijo 'L'
```

#### long long
- **Tamaño**: 8 bytes (64 bits)
- **Rango**: -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807
- **Caso de uso**: Enteros muy grandes

```c
long long distancia_estrella = 9460730472580800LL;  // Año luz en km
```

### 1.2 Tipos de Punto Flotante

#### float
- **Tamaño**: 4 bytes (32 bits)
- **Precisión**: ~6-7 dígitos decimales
- **Rango**: ±3.4E±38
- **Caso de uso**: Aritmética de punto flotante general

```c
float precio = 19.99f;        // Nota el sufijo 'f'
float pi_aprox = 3.14159f;
```

#### double
- **Tamaño**: 8 bytes (64 bits)
- **Precisión**: ~15-16 dígitos decimales
- **Rango**: ±1.7E±308
- **Caso de uso**: Cálculos de alta precisión (predeterminado para literales flotantes)

```c
double pi_preciso = 3.141592653589793;
double cientifico = 1.23e-4;  // Notación científica
```

#### long double
- **Tamaño**: Dependiente del sistema (típicamente 10, 12 o 16 bytes)
- **Precisión**: Mayor que double
- **Caso de uso**: Cálculos de máxima precisión

```c
long double ultra_preciso = 3.141592653589793238L;
```

### 1.3 Modificadores de Tipo

#### signed y unsigned
- **signed**: Puede almacenar valores positivos y negativos (predeterminado para la mayoría de tipos)
- **unsigned**: Solo valores positivos, duplica el rango positivo

```c
unsigned int solo_positivo = 4294967295U;
signed int puede_ser_negativo = -2000000000;

// Combinaciones unsigned comunes
unsigned char byte = 255;
unsigned short puerto = 8080;
unsigned long id = 123456789UL;
```

### 1.4 Verificación del Tamaño de Tipos

```c
#include <stdio.h>

int main() {
    printf("Tamaño de char: %zu bytes\n", sizeof(char));
    printf("Tamaño de int: %zu bytes\n", sizeof(int));
    printf("Tamaño de long: %zu bytes\n", sizeof(long));
    printf("Tamaño de float: %zu bytes\n", sizeof(float));
    printf("Tamaño de double: %zu bytes\n", sizeof(double));
    return 0;
}
```

## Capítulo 2: Constantes y Literales

### 2.1 Definición de Constantes

#### Usando la Directiva del Preprocesador #define
```c
#define PI 3.14159
#define MAX_ESTUDIANTES 100
#define MENSAJE_BIENVENIDA "¡Hola, Mundo!"
#define NUEVA_LINEA '\n'
```

#### Usando la Palabra Clave const (Método Preferido)
```c
const int MAX_INTENTOS = 3;
const float GRAVEDAD = 9.81f;
const char SEPARADOR = ',';
const double E = 2.718281828;
```

### 2.2 Tipos de Literales
```c
// Literales enteros
int decimal = 42;
int octal = 052;        // Octal (comienza con 0)
int hexadecimal = 0x2A; // Hexadecimal (comienza con 0x)

// Literales de punto flotante
float f_literal = 3.14f;
double d_literal = 3.14;
double cientifico = 1.5e-3;  // 0.0015

// Literales de carácter
char caracter_simple = 'A';
char caracter_escape = '\n';     // Nueva línea
char caracter_tab = '\t';        // Tabulación
```

## Capítulo 3: Operaciones Aritméticas

### 3.1 Operadores Aritméticos Básicos

| Operador | Descripción | Ejemplo | Tipo de Resultado |
|----------|-------------|---------|-------------------|
| `+` | Suma | `5 + 3` | Mismo que los operandos |
| `-` | Resta | `10 - 4` | Mismo que los operandos |
| `*` | Multiplicación | `7 * 2` | Mismo que los operandos |
| `/` | División | `15 / 3` | Mismo que los operandos |
| `%` | Módulo (resto) | `17 % 5` | Solo enteros |

### 3.2 Comportamiento Importante de la División

```c
#include <stdio.h>

int main() {
    // La división entera trunca
    int resultado_int = 7 / 3;        // Resultado: 2 (no 2.33)
    
    // División de punto flotante
    float resultado_float = 7.0f / 3.0f;  // Resultado: 2.333333
    
    // División mixta (ocurre promoción)
    float resultado_mixto = 7 / 3.0f;     // Resultado: 2.333333
    
    // Conversión explícita
    float resultado_cast = (float)7 / 3;   // Resultado: 2.333333
    
    printf("División entera: %d\n", resultado_int);
    printf("División flotante: %.6f\n", resultado_float);
    printf("División mixta: %.6f\n", resultado_mixto);
    printf("División con cast: %.6f\n", resultado_cast);
    
    return 0;
}
```

### 3.3 Especificaciones del Operador Módulo

```c
// El módulo solo funciona con enteros
int resto = 17 % 5;  // Resultado: 2
int negativo = -17 % 5;  // Resultado: -2 (el signo sigue al dividendo)

// Usos comunes del módulo
int es_par = (numero % 2 == 0);  // Verificar si es par
int ultimo_digito = numero % 10;     // Obtener último dígito
int circular = indice % tamaño_array;  // Indexación circular
```

## Capítulo 4: Operaciones de Asignación

### 4.1 Asignación Simple
```c
int x = 10;       // Inicialización
x = 20;           // Asignación
```

### 4.2 Operadores de Asignación Compuesta

| Operador | Equivalente | Descripción |
|----------|-------------|-------------|
| `+=` | `x = x + y` | Sumar y asignar |
| `-=` | `x = x - y` | Restar y asignar |
| `*=` | `x = x * y` | Multiplicar y asignar |
| `/=` | `x = x / y` | Dividir y asignar |
| `%=` | `x = x % y` | Módulo y asignar |

```c
int valor = 10;
valor += 5;   // valor = 15
valor -= 3;   // valor = 12
valor *= 2;   // valor = 24
valor /= 4;   // valor = 6
valor %= 4;   // valor = 2
```

### 4.3 Operadores de Incremento y Decremento

```c
int a = 5, b = 5;

// Pre-incremento: incrementar primero, luego usar el valor
int pre_inc = ++a;   // a = 6, pre_inc = 6

// Post-incremento: usar el valor primero, luego incrementar
int post_inc = b++;  // b = 6, post_inc = 5

// La misma lógica aplica al decremento
int c = 8, d = 8;
int pre_dec = --c;   // c = 7, pre_dec = 7
int post_dec = d--;  // d = 7, post_dec = 8
```

## Capítulo 5: Operaciones de Comparación y Lógicas

### 5.1 Operadores de Comparación

| Operador | Descripción | Retorna |
|----------|-------------|---------|
| `==` | Igual a | 1 (verdadero) o 0 (falso) |
| `!=` | No igual a | 1 (verdadero) o 0 (falso) |
| `<` | Menor que | 1 (verdadero) o 0 (falso) |
| `<=` | Menor o igual que | 1 (verdadero) o 0 (falso) |
| `>` | Mayor que | 1 (verdadero) o 0 (falso) |
| `>=` | Mayor o igual que | 1 (verdadero) o 0 (falso) |

```c
int x = 5, y = 10;
int igual = (x == y);        // 0 (falso)
int no_igual = (x != y);     // 1 (verdadero)
int menor = (x < y);         // 1 (verdadero)
int mayor = (x > y);         // 0 (falso)
```

### 5.2 Operadores Lógicos

| Operador | Descripción | Comportamiento |
|----------|-------------|----------------|
| `&&` | AND Lógico | Evaluación de cortocircuito |
| `\|\|` | OR Lógico | Evaluación de cortocircuito |
| `!` | NOT Lógico | Operador unario |

```c
int edad = 20;
int tiene_licencia = 1;

// AND Lógico
if (edad >= 18 && tiene_licencia) {
    printf("Puede conducir\n");
}

// OR Lógico
if (edad < 18 || !tiene_licencia) {
    printf("No puede conducir\n");
}

// NOT Lógico
int es_menor = !(edad >= 18);
```

### 5.3 Evaluación de Cortocircuito

```c
int x = 0;
int y = 5;

// En operación AND, si el primer operando es falso, el segundo no se evalúa
if (x != 0 && y / x > 2) {  // Seguro: y/x no se ejecutará si x == 0
    printf("División segura\n");
}

// En operación OR, si el primer operando es verdadero, el segundo no se evalúa
if (x == 0 || y / x > 2) {  // y/x no se ejecutará si x == 0
    printf("O x es cero o el resultado de la división > 2\n");
}
```

## Capítulo 6: Conversiones de Tipo

### 6.1 Conversión Implícita (Automática)

C promueve automáticamente tipos en expresiones siguiendo estas reglas:
1. `char` y `short` → `int`
2. `float` → `double` en argumentos de función
3. Menor precisión → Mayor precisión en expresiones mixtas

```c
char c = 'A';
int i = 10;
float f = 3.14f;
double d = 2.718;

int resultado1 = c + i;      // char promovido a int
double resultado2 = f + d;   // float promovido a double
double resultado3 = i + d;   // int promovido a double
```

### 6.2 Conversión Explícita (Casting)

```c
float pi = 3.14159f;
int truncado = (int)pi;  // 3 (se pierde la parte decimal)

int numerador = 7, denominador = 3;
float division = (float)numerador / denominador;  // 2.333333

// Conversión entre diferentes tipos enteros
long numero_grande = 1000000L;
int menor = (int)numero_grande;  // Posible pérdida de datos si es muy grande
```

### 6.3 Advertencias de Conversión y Mejores Prácticas

```c
// Advertencias de posible pérdida de datos
int grande = 300;
char pequeño = (char)grande;  // Pérdida de datos: 300 > 255 (rango de char)

// Conversiones seguras
unsigned int positivo = 100;
int valor_con_signo = (int)positivo;  // Seguro si está dentro del rango

// Consideraciones de precisión de punto flotante
float f = 1.23456789f;     // Solo ~6-7 dígitos de precisión
double d = (double)f;      // No añade precisión, solo extiende el formato
```

## Capítulo 7: Precedencia y Asociatividad de Operadores

### 7.1 Tabla de Precedencia (Alta a Baja)

| Prioridad | Operadores | Asociatividad | Descripción |
|-----------|------------|---------------|-------------|
| 1 | `()` `[]` `->` `.` | Izquierda a Derecha | Primarios |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `sizeof` | Derecha a Izquierda | Unarios |
| 3 | `*` `/` `%` | Izquierda a Derecha | Multiplicativos |
| 4 | `+` `-` | Izquierda a Derecha | Aditivos |
| 5 | `<` `<=` `>` `>=` | Izquierda a Derecha | Relacionales |
| 6 | `==` `!=` | Izquierda a Derecha | Igualdad |
| 7 | `&&` | Izquierda a Derecha | AND Lógico |
| 8 | `\|\|` | Izquierda a Derecha | OR Lógico |
| 9 | `=` `+=` `-=` `*=` `/=` `%=` | Derecha a Izquierda | Asignación |

### 7.2 Ejemplos de Precedencia

```c
// Sin paréntesis
int resultado1 = 2 + 3 * 4;        // 14, no 20 (* antes que +)
int resultado2 = 10 - 6 / 2;       // 7, no 2 (/ antes que -)

// Con paréntesis para claridad
int resultado3 = (2 + 3) * 4;      // 20
int resultado4 = (10 - 6) / 2;     // 2

// Operaciones mixtas
int complejo = 2 + 3 * 4 > 10;     // 1 (verdadero): (2 + 12) > 10
```

## Capítulo 8: Operaciones de Entrada/Salida

### 8.1 Salida con printf()

#### Especificadores de Formato Comunes

| Especificador | Tipo de Dato | Descripción | Ejemplo |
|---------------|--------------|-------------|---------|
| `%d` | int | Entero decimal | `printf("%d", 42)` |
| `%u` | unsigned int | Entero sin signo | `printf("%u", 42U)` |
| `%ld` | long | Entero largo | `printf("%ld", 42L)` |
| `%f` | float/double | Punto flotante | `printf("%f", 3.14)` |
| `%e` | float/double | Notación científica | `printf("%e", 3.14)` |
| `%g` | float/double | Representación más corta | `printf("%g", 3.14)` |
| `%c` | char | Carácter único | `printf("%c", 'A')` |
| `%s` | char* | Cadena | `printf("%s", "Hola")` |

#### Opciones de Formato

```c
int numero = 42;
float pi = 3.14159f;

printf("Básico: %d\n", numero);
printf("Ancho: %5d\n", numero);           // Alineado a la derecha en 5 espacios
printf("Alineado izquierda: %-5d|\n", numero);  // Alineado a la izquierda
printf("Rellenado con ceros: %05d\n", numero);    // Rellenado con ceros

printf("Float: %f\n", pi);
printf("Precisión: %.2f\n", pi);          // 2 lugares decimales
printf("Científico: %e\n", pi);
printf("Compacto: %g\n", pi);
```

### 8.2 Entrada con scanf()

```c
int edad;
float altura;
char calificacion;
char nombre[50];

printf("Ingrese su edad: ");
scanf("%d", &edad);  // Nota el & (operador de dirección)

printf("Ingrese su altura: ");
scanf("%f", &altura);

printf("Ingrese su calificación: ");
scanf(" %c", &calificacion);  // Espacio antes de %c para saltar espacios en blanco

printf("Ingrese su nombre: ");
scanf("%s", nombre);     // No se usa & para arrays
```

### 8.3 Manejo Seguro de Entrada

```c
#include <stdio.h>

int main() {
    int numero;
    char buffer[100];
    
    printf("Ingrese un número: ");
    
    // Entrada segura con verificación de errores
    if (scanf("%d", &numero) == 1) {
        printf("Usted ingresó: %d\n", numero);
    } else {
        printf("¡Entrada inválida!\n");
        // Limpiar buffer de entrada
        while (getchar() != '\n');
    }
    
    return 0;
}
```

## Capítulo 9: Ejemplos Prácticos

### 9.1 Calculadora Avanzada

```c
#include <stdio.h>
#include <math.h>

int main() {
    double num1, num2, resultado;
    char operador;
    
    printf("=== CALCULADORA CIENTÍFICA ===\n");
    printf("Operaciones soportadas: +, -, *, /, ^, s(raíz), l(log)\n");
    
    printf("Ingrese el primer número: ");
    scanf("%lf", &num1);
    
    printf("Ingrese el operador: ");
    scanf(" %c", &operador);
    
    if (operador != 's' && operador != 'l') {
        printf("Ingrese el segundo número: ");
        scanf("%lf", &num2);
    }
    
    switch(operador) {
        case '+':
            resultado = num1 + num2;
            printf("%.2f + %.2f = %.2f\n", num1, num2, resultado);
            break;
        case '-':
            resultado = num1 - num2;
            printf("%.2f - %.2f = %.2f\n", num1, num2, resultado);
            break;
        case '*':
            resultado = num1 * num2;
            printf("%.2f * %.2f = %.2f\n", num1, num2, resultado);
            break;
        case '/':
            if (num2 != 0.0) {
                resultado = num1 / num2;
                printf("%.2f / %.2f = %.2f\n", num1, num2, resultado);
            } else {
                printf("Error: ¡División por cero!\n");
                return 1;
            }
            break;
        case '^':
            resultado = pow(num1, num2);
            printf("%.2f ^ %.2f = %.2f\n", num1, num2, resultado);
            break;
        case 's':
            if (num1 >= 0) {
                resultado = sqrt(num1);
                printf("raíz(%.2f) = %.2f\n", num1, resultado);
            } else {
                printf("Error: ¡No se puede calcular la raíz cuadrada de un número negativo!\n");
                return 1;
            }
            break;
        case 'l':
            if (num1 > 0) {
                resultado = log(num1);
                printf("ln(%.2f) = %.2f\n", num1, resultado);
            } else {
                printf("Error: ¡No se puede calcular el logaritmo de un número no positivo!\n");
                return 1;
            }
            break;
        default:
            printf("Error: ¡Operador inválido!\n");
            return 1;
    }
    
    return 0;
}
```

### 9.2 Demostración de Conversión de Tipos

```c
#include <stdio.h>
#include <limits.h>
#include <float.h>

int main() {
    printf("=== DEMOSTRACIÓN DE TIPOS DE DATOS EN C ===\n\n");
    
    // Tipos enteros y sus límites
    printf("TIPOS ENTEROS:\n");
    printf("char: %d a %d (tamaño: %zu bytes)\n", CHAR_MIN, CHAR_MAX, sizeof(char));
    printf("short: %d a %d (tamaño: %zu bytes)\n", SHRT_MIN, SHRT_MAX, sizeof(short));
    printf("int: %d a %d (tamaño: %zu bytes)\n", INT_MIN, INT_MAX, sizeof(int));
    printf("long: %ld a %ld (tamaño: %zu bytes)\n", LONG_MIN, LONG_MAX, sizeof(long));
    
    // Tipos de punto flotante
    printf("\nTIPOS DE PUNTO FLOTANTE:\n");
    printf("float: precisión %d dígitos (tamaño: %zu bytes)\n", FLT_DIG, sizeof(float));
    printf("double: precisión %d dígitos (tamaño: %zu bytes)\n", DBL_DIG, sizeof(double));
    printf("long double: precisión %d dígitos (tamaño: %zu bytes)\n", LDBL_DIG, sizeof(long double));
    
    // Ejemplos de conversión
    printf("\nEJEMPLOS DE CONVERSIÓN:\n");
    
    int val_int = 42;
    float val_float = 3.14159f;
    char val_char = 'A';
    
    printf("Valores originales:\n");
    printf("int: %d, float: %.5f, char: %c (%d)\n", 
           val_int, val_float, val_char, val_char);
    
    // Conversiones implícitas
    printf("\nConversiones implícitas:\n");
    printf("int a float: %d -> %.2f\n", val_int, (float)val_int);
    printf("float a int: %.5f -> %d\n", val_float, (int)val_float);
    printf("char a int: '%c' -> %d\n", val_char, (int)val_char);
    
    // Aritmética con tipos mixtos
    printf("\nAritmética mixta:\n");
    float resultado_mixto = val_int + val_float;
    printf("int + float: %d + %.5f = %.5f\n", val_int, val_float, resultado_mixto);
    
    return 0;
}
```

### 9.3 Conversor de Unidades

```c
#include <stdio.h>

int main() {
    int opcion;
    double entrada, resultado;
    
    printf("=== CONVERSOR DE UNIDADES ===\n");
    printf("1. Celsius a Fahrenheit\n");
    printf("2. Fahrenheit a Celsius\n");
    printf("3. Metros a Pies\n");
    printf("4. Pies a Metros\n");
    printf("5. Kilogramos a Libras\n");
    printf("6. Libras a Kilogramos\n");
    printf("Ingrese su opción (1-6): ");
    
    scanf("%d", &opcion);
    
    printf("Ingrese el valor a convertir: ");
    scanf("%lf", &entrada);
    
    switch(opcion) {
        case 1:
            resultado = (entrada * 9.0/5.0) + 32.0;
            printf("%.2f°C = %.2f°F\n", entrada, resultado);
            break;
        case 2:
            resultado = (entrada - 32.0) * 5.0/9.0;
            printf("%.2f°F = %.2f°C\n", entrada, resultado);
            break;
        case 3:
            resultado = entrada * 3.28084;
            printf("%.2f metros = %.2f pies\n", entrada, resultado);
            break;
        case 4:
            resultado = entrada / 3.28084;
            printf("%.2f pies = %.2f metros\n", entrada, resultado);
            break;
        case 5:
            resultado = entrada * 2.20462;
            printf("%.2f kg = %.2f lbs\n", entrada, resultado);
            break;
        case 6:
            resultado = entrada / 2.20462;
            printf("%.2f lbs = %.2f kg\n", entrada, resultado);
            break;
        default:
            printf("¡Opción inválida!\n");
            return 1;
    }
    
    return 0;
}
```

## Capítulo 10: Mejores Prácticas y Errores Comunes

### 10.1 Mejores Prácticas

1. **Siempre inicializar variables**
   ```c
   int contador = 0;        // Bueno
   int variable_indefinida; // Peligroso - contiene basura
   ```

2. **Usar tipos de datos apropiados**
   ```c
   unsigned int edad = 25;     // La edad no puede ser negativa
   float precio = 19.99f;      // Usar float para cálculos monetarios
   const int TAMAÑO_MAX = 100; // Constantes para valores fijos
   ```

3. **Ser explícito con conversiones de tipo**
   ```c
   float resultado = (float)numerador / denominador;  // Intención clara
   ```

4. **Usar paréntesis para claridad**
   ```c
   int resultado = (a + b) * (c - d);  // Precedencia clara
   ```

5. **Verificar división por cero**
   ```c
   if (denominador != 0) {
       resultado = numerador / denominador;
   } else {
       printf("Error: ¡División por cero!\n");
   }
   ```

### 10.2 Errores Comunes

1. **Truncamiento de división entera**
   ```c
   int incorrecto = 5 / 2;        // Resultado: 2, no 2.5
   float correcto = 5.0f / 2;     // Resultado: 2.5
   ```

2. **Comparación de punto flotante**
   ```c
   // Forma incorrecta
   if (valor_float == 3.14) { ... }
   
   // Mejor forma
   #include <math.h>
   if (fabs(valor_float - 3.14) < 0.001) { ... }
   ```

3. **Desbordamiento y subdesbordamiento**
   ```c
   unsigned char valor = 255;
   valor++;  // Resultado: 0 (desbordamiento circular)
   
   signed char pequeño = -128;
   pequeño--;  // Comportamiento indefinido (subdesbordamiento)
   ```

4. **Módulo con números negativos**
   ```c
   int resultado = -17 % 5;  // Resultado: -2 (no 3)
   ```

5. **Asignación vs. comparación**
   ```c
   int x = 5;
   if (x = 3) { ... }     // ¡Asignación! Siempre verdadero (x se vuelve 3)
   if (x == 3) { ... }    // Comparación - esto es lo que quieres
   ```

### 10.3 Consejos de Depuración

1. **Usar printf para depuración**
   ```c
   printf("Depuración: x = %d, y = %d\n", x, y);
   ```

2. **Verificar valores de variables en puntos clave**
   ```c
   printf("Antes del cálculo: a = %d\n", a);
   resultado = calculo_complejo(a);
   printf("Después del cálculo: resultado = %d\n", resultado);
   ```

3. **Validar entrada**
   ```c
   if (scanf("%d", &numero) != 1) {
       printf("¡Entrada inválida!\n");
       return 1;
   }
   ```

## Conclusión

Comprender los tipos de datos y operaciones de C es crucial para una programación efectiva. Esta guía completa cubre:

- Sistema completo de tipos de datos con tamaños y rangos
- Todas las operaciones aritméticas, lógicas y de comparación
- Mecanismos de conversión de tipos y mejores prácticas
- Formato de entrada/salida y manejo de errores
- Ejemplos del mundo real y aplicaciones prácticas
- Errores comunes y cómo evitarlos

Dominar estos fundamentos proporcionará una base sólida para conceptos avanzados de programación en C como punteros, arrays, estructuras y manejo de memoria.

## Referencia Rápida

### Cabeceras Esenciales
```c
#include <stdio.h>     // Funciones de entrada/salida
#include <limits.h>    // Límites de tipos enteros
#include <float.h>     // Límites de tipos de punto flotante
#include <math.h>      // Funciones matemáticas
```

### Macros de Verificación de Tipos
```c
sizeof(tipo)    // Tamaño del tipo en bytes
INT_MAX        // Valor máximo de int
FLT_DIG        // Precisión de float en dígitos
```

### Patrones de Programación Segura
```c
// División segura
if (b != 0) resultado = a / b;

// Entrada segura
if (scanf("%d", &var) == 1) { /* procesar */ }

// Comparación segura para flotantes
if (fabs(f1 - f2) < EPSILON) { /* iguales */ }
```

## Ejercicios Propuestos

### Ejercicios Básicos

1. **Calculadora de Área**: Escriba un programa que calcule el área y perímetro de diferentes figuras geométricas (rectángulo, círculo, triángulo).

2. **Conversor de Bases**: Implemente un programa que convierta números entre decimal, binario y hexadecimal.

3. **Análisis de Números**: Cree un programa que determine si un número es par/impar, positivo/negativo, y calcule su factorial.

### Ejercicios Intermedios

4. **Calculadora de Interés Compuesto**: Desarrolle una calculadora que calcule interés simple y compuesto con validación de entrada.

5. **Verificador de Tipos**: Escriba un programa que muestre los rangos y tamaños de todos los tipos de datos en su sistema.

6. **Operaciones Bitwise**: Implemente operaciones a nivel de bits para manipular flags y máscaras.

### Ejercicios Avanzados

7. **Simulador de Punto Flotante**: Cree un programa que demuestre los problemas de precisión en aritmética de punto flotante.

8. **Conversor Universal**: Desarrolle un sistema completo de conversión de unidades con menú interactivo y validación robusta.

9. **Analizador de Expresiones**: Implemente un evaluador simple de expresiones matemáticas respetando la precedencia de operadores.

## Glosario de Términos

**Casting**: Conversión explícita de un tipo de dato a otro mediante el operador de conversión `(tipo)`.

**Desbordamiento (Overflow)**: Cuando un valor excede el rango máximo que puede representar un tipo de dato.

**Evaluación de Cortocircuito**: Optimización donde el segundo operando de `&&` o `||` no se evalúa si el resultado ya se puede determinar con el primero.

**Literal**: Valor constante que se escribe directamente en el código fuente (ej: `42`, `3.14f`, `'A'`).

**Precedencia**: Orden en que se evalúan los operadores en una expresión compleja.

**Promoción de Tipos**: Conversión automática de tipos más pequeños a tipos más grandes en expresiones.

**Subdesbordamiento (Underflow)**: Cuando un valor es menor que el rango mínimo que puede representar un tipo de dato.

**Truncamiento**: Pérdida de la parte decimal cuando se convierte un número de punto flotante a entero.

## Recursos Adicionales

### Documentación Recomendada
- Estándar ISO C11/C18
- Manual de referencia de GNU GCC
- Documentación de bibliotecas estándar de C

### Herramientas Útiles
- **Compiladores**: GCC, Clang, MSVC
- **Depuradores**: GDB, LLDB, Visual Studio Debugger
- **Analizadores**: Valgrind, AddressSanitizer
- **IDEs**: Code::Blocks, Dev-C++, Visual Studio, CLion

### Libros de Referencia
- "The C Programming Language" por Kernighan y Ritchie
- "C Programming: A Modern Approach" por K.N. King
- "Expert C Programming" por Peter van der Linden

---

*Guía Completa de Tipos de Datos y Operaciones en C - Referencia de Programación Avanzada*