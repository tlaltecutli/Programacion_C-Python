# Variables y Tipos de Datos en C

## Índice
1. [Introducción a Variables](#1-introducción-a-variables)
2. [Tipos de Datos Básicos](#2-tipos-de-datos-básicos)
3. [Declaración y Definición](#3-declaración-y-definición)
4. [Modificadores de Tipo](#4-modificadores-de-tipo)
5. [Constantes](#5-constantes)
6. [Ámbito y Duración](#6-ámbito-y-duración)
7. [Conversión de Tipos](#7-conversión-de-tipos)
8. [Tipos Derivados](#8-tipos-derivados)
9. [Buenas Prácticas](#9-buenas-prácticas)
10. [Ejercicios Prácticos](#10-ejercicios-prácticos)
11. [Conceptos Avanzados](#11-conceptos-avanzados)
12. [Debugging y Herramientas](#12-debugging-y-herramientas)
13. [Resumen y Mejores Prácticas](#13-resumen-y-mejores-prácticas)

---

## 1. Introducción a Variables

### 1.1 ¿Qué es una Variable?

Una **variable** es un espacio reservado en la memoria del computador que tiene:
- Un **nombre** (identificador)
- Un **tipo** de dato
- Un **valor** almacenado
- Una **dirección** de memoria

### 1.2 Analogía Conceptual

Piensa en una variable como una **caja etiquetada**:
- La etiqueta es el **nombre** de la variable
- El **tamaño** de la caja determina qué tipo de dato puede almacenar
- El **contenido** es el valor actual
- La **ubicación** de la caja es su dirección en memoria

### 1.3 Características de las Variables en C

```c
#include <stdio.h>

int main() {
    // Declaración: Se reserva espacio en memoria
    int edad;
    
    // Definición/Inicialización: Se asigna un valor
    edad = 25;
    
    // Uso: Se accede al valor
    printf("La edad es: %d años\n", edad);
    
    return 0;
}
```

### 1.4 Reglas para Nombres de Variables

#### Reglas Obligatorias:
1. **Primer carácter**: Debe ser letra (a-z, A-Z) o guión bajo (_)
2. **Caracteres posteriores**: Letras, dígitos (0-9) o guión bajo
3. **Case-sensitive**: `edad` y `Edad` son variables diferentes
4. **No palabras reservadas**: No usar `int`, `if`, `while`, etc.

#### Ejemplos Válidos:
```c
int edad;           // ✅ Correcto
int _contador;      // ✅ Correcto
int numero1;        // ✅ Correcto
int miVariable;     // ✅ Correcto (camelCase)
int mi_variable;    // ✅ Correcto (snake_case)
```

#### Ejemplos Inválidos:
```c
int 2numero;        // ❌ No puede empezar con dígito
int numero-edad;    // ❌ No puede contener guión
int int;           // ❌ Palabra reservada
int mi variable;   // ❌ No puede contener espacios
```

---

## 2. Tipos de Datos Básicos

### 2.1 Tipos Fundamentales

C proporciona varios tipos de datos básicos:

| Tipo | Descripción | Tamaño (típico) | Rango (típico) |
|------|-------------|-----------------|----------------|
| `char` | Carácter | 1 byte | -128 a 127 |
| `int` | Entero | 4 bytes | -2,147,483,648 a 2,147,483,647 |
| `float` | Punto flotante | 4 bytes | ±3.4E-38 a ±3.4E+38 |
| `double` | Doble precisión | 8 bytes | ±1.7E-308 a ±1.7E+308 |
| `void` | Vacío | - | Sin valor |

### 2.2 Tipo char (Carácter)

```c
#include <stdio.h>

int main() {
    // Declaración e inicialización
    char letra = 'A';
    char digito = '7';
    char simbolo = '$';
    
    // También se puede usar valor ASCII
    char caracter_ascii = 65;  // Equivale a 'A'
    
    printf("Letra: %c\n", letra);
    printf("Dígito: %c\n", digito);
    printf("Símbolo: %c\n", simbolo);
    printf("ASCII 65: %c\n", caracter_ascii);
    
    // Mostrar valores ASCII
    printf("ASCII de 'A': %d\n", letra);
    printf("ASCII de '7': %d\n", digito);
    
    return 0;
}
```

#### Caracteres Especiales:
```c
#include <stdio.h>

int main() {
    char nueva_linea = '\n';    // Nueva línea
    char tabulacion = '\t';     // Tabulación
    char retroceso = '\b';      // Backspace
    char comilla = '\'';        // Comilla simple
    char barra_invertida = '\\'; // Barra invertida
    
    printf("Hola%cMundo\n", nueva_linea);     // Hola\nMundo
    printf("Columna1%cColumna2\n", tabulacion); // Columna1\tColumna2
    
    return 0;
}
```

### 2.3 Tipo int (Entero)

```c
#include <stdio.h>

int main() {
    // Diferentes formas de inicializar
    int numero1 = 42;           // Decimal
    int numero2 = 052;          // Octal (empieza con 0)
    int numero3 = 0x2A;         // Hexadecimal (empieza con 0x)
    
    int positivo = 100;
    int negativo = -50;
    int cero = 0;
    
    printf("Decimal: %d\n", numero1);
    printf("Octal: %d (valor decimal)\n", numero2);
    printf("Hexadecimal: %d (valor decimal)\n", numero3);
    
    // Operaciones básicas
    int suma = positivo + negativo;
    int producto = positivo * 2;
    int division = positivo / 3;  // División entera
    int resto = positivo % 7;     // Módulo
    
    printf("Suma: %d + %d = %d\n", positivo, negativo, suma);
    printf("Producto: %d * 2 = %d\n", positivo, producto);
    printf("División: %d / 3 = %d\n", positivo, division);
    printf("Resto: %d %% 7 = %d\n", positivo, resto);
    
    return 0;
}
```

### 2.4 Tipo float (Punto Flotante)

```c
#include <stdio.h>

int main() {
    // Declaración con diferentes precisiones
    float pi = 3.14159f;        // Sufijo 'f' para float
    float cientifico = 1.23e-4f; // Notación científica
    float negativo = -2.718f;
    
    // Operaciones
    float radio = 5.0f;
    float area = pi * radio * radio;
    float circunferencia = 2.0f * pi * radio;
    
    printf("Pi: %.5f\n", pi);
    printf("Científico: %.2e\n", cientifico);
    printf("Radio: %.1f\n", radio);
    printf("Área: %.2f\n", area);
    printf("Circunferencia: %.2f\n", circunferencia);
    
    // Precisión limitada de float
    float precision = 1.0f / 3.0f;
    printf("1/3 como float: %.10f\n", precision);
    
    return 0;
}
```

### 2.5 Tipo double (Doble Precisión)

```c
#include <stdio.h>

int main() {
    // Mayor precisión que float
    double pi_preciso = 3.141592653589793;
    double euler = 2.718281828459045;
    double muy_grande = 1.23e100;
    double muy_pequeño = 1.23e-100;
    
    printf("Pi (double): %.15f\n", pi_preciso);
    printf("Euler: %.15f\n", euler);
    printf("Muy grande: %.2e\n", muy_grande);
    printf("Muy pequeño: %.2e\n", muy_pequeño);
    
    // Comparación de precisión
    float pi_float = 3.141592653589793f;
    double pi_double = 3.141592653589793;
    
    printf("Pi como float:  %.15f\n", pi_float);
    printf("Pi como double: %.15f\n", pi_double);
    
    // Cálculos que requieren precisión
    double resultado = 1.0 / 3.0;
    printf("1/3 como double: %.15f\n", resultado);
    
    return 0;
}
```

### 2.6 Verificación de Tamaños

```c
#include <stdio.h>

int main() {
    printf("=== TAMAÑOS DE TIPOS DE DATOS ===\n");
    printf("char:    %zu bytes\n", sizeof(char));
    printf("int:     %zu bytes\n", sizeof(int));
    printf("float:   %zu bytes\n", sizeof(float));
    printf("double:  %zu bytes\n", sizeof(double));
    printf("void*:   %zu bytes\n", sizeof(void*));
    
    // Rangos aproximados
    printf("\n=== RANGOS APROXIMADOS ===\n");
    printf("char:   %d a %d\n", -128, 127);
    printf("int:    %d a %d\n", -2147483648, 2147483647);
    printf("float:  ±%.1e a ±%.1e\n", 3.4e-38, 3.4e+38);
    printf("double: ±%.1e a ±%.1e\n", 1.7e-308, 1.7e+308);
    
    return 0;
}
```

---

## 3. Declaración y Definición

### 3.1 Diferencias Conceptuales

- **Declaración**: Informa al compilador sobre la existencia de una variable
- **Definición**: Reserva memoria para la variable
- **Inicialización**: Asigna un valor inicial

### 3.2 Sintaxis Básica

```c
#include <stdio.h>

int main() {
    // Declaración simple
    int edad;
    
    // Declaración con inicialización
    int año = 2024;
    
    // Múltiples declaraciones del mismo tipo
    int x, y, z;
    
    // Múltiples declaraciones con inicialización
    int a = 1, b = 2, c = 3;
    
    // Diferentes tipos
    char inicial = 'J';
    float altura = 1.75f;
    double peso = 70.5;
    
    // Asignación posterior a la declaración
    edad = 25;
    x = 10;
    y = 20;
    z = x + y;
    
    printf("Edad: %d, Año: %d\n", edad, año);
    printf("Variables: a=%d, b=%d, c=%d\n", a, b, c);
    printf("Suma: %d + %d = %d\n", x, y, z);
    printf("Datos personales: %c, %.2fm, %.1fkg\n", inicial, altura, peso);
    
    return 0;
}
```

### 3.3 Inicialización vs Asignación

```c
#include <stdio.h>

int main() {
    // ✅ Inicialización (recomendado)
    int numero_inicializado = 42;
    
    // ⚠️ Declaración sin inicialización
    int numero_no_inicializado;
    
    // ✅ Asignación posterior
    numero_no_inicializado = 10;
    
    printf("Inicializado: %d\n", numero_inicializado);
    printf("Asignado después: %d\n", numero_no_inicializado);
    
    // ❌ Peligro: usar variable no inicializada
    int peligroso;
    // printf("%d\n", peligroso);  // Valor impredecible!
    
    return 0;
}
```

### 3.4 Declaraciones Especiales

#### Variables Automáticas:
```c
#include <stdio.h>

void funcion() {
    auto int variable_auto = 10;  // 'auto' es redundante
    int variable_normal = 20;     // Equivalente a la anterior
    
    printf("Auto: %d, Normal: %d\n", variable_auto, variable_normal);
} // Las variables se destruyen aquí
```

#### Variables Estáticas:
```c
#include <stdio.h>

void contador() {
    static int count = 0;  // Se inicializa solo una vez
    count++;
    printf("Llamada número: %d\n", count);
} // 'count' mantiene su valor entre llamadas

int main() {
    contador();  // Imprime: 1
    contador();  // Imprime: 2
    contador();  // Imprime: 3
    return 0;
}
```

---

## 4. Modificadores de Tipo

### 4.1 Modificadores de Tamaño

#### short y long
```c
#include <stdio.h>

int main() {
    // Modificadores de tamaño
    short int numero_corto = 32767;      // o simplemente: short
    int numero_normal = 2147483647;
    long int numero_largo = 2147483647L;  // o simplemente: long
    long long int numero_muy_largo = 9223372036854775807LL;
    
    printf("short:     %hd (tamaño: %zu bytes)\n", numero_corto, sizeof(short));
    printf("int:       %d (tamaño: %zu bytes)\n", numero_normal, sizeof(int));
    printf("long:      %ld (tamaño: %zu bytes)\n", numero_largo, sizeof(long));
    printf("long long: %lld (tamaño: %zu bytes)\n", numero_muy_largo, sizeof(long long));
    
    return 0;
}
```

### 4.2 Modificadores de Signo

#### signed y unsigned
```c
#include <stdio.h>

int main() {
    // Con signo (por defecto)
    signed char char_con_signo = -128;        // -128 a 127
    signed int int_con_signo = -2147483648;   // Por defecto
    
    // Sin signo
    unsigned char char_sin_signo = 255;       // 0 a 255
    unsigned int int_sin_signo = 4294967295U; // 0 a 4,294,967,295
    
    printf("Char con signo: %d\n", char_con_signo);
    printf("Char sin signo: %u\n", char_sin_signo);
    printf("Int con signo: %d\n", int_con_signo);
    printf("Int sin signo: %u\n", int_sin_signo);
    
    // Demostración de overflow
    unsigned char contador = 250;
    printf("Contador inicial: %u\n", contador);
    contador += 10;  // 250 + 10 = 260, pero overflow a 4
    printf("Después de +10: %u\n", contador);
    
    return 0;
}
```

### 4.3 Combinación de Modificadores

```c
#include <stdio.h>

int main() {
    // Todas las combinaciones posibles
    unsigned short us = 65535;
    signed short ss = -32768;
    unsigned long ul = 4294967295UL;
    signed long sl = -2147483648L;
    unsigned long long ull = 18446744073709551615ULL;
    
    printf("unsigned short:     %hu\n", us);
    printf("signed short:       %hd\n", ss);
    printf("unsigned long:      %lu\n", ul);
    printf("signed long:        %ld\n", sl);
    printf("unsigned long long: %llu\n", ull);
    
    return 0;
}
```

---

## 5. Constantes

### 5.1 Constantes con #define

```c
#include <stdio.h>

// Definición de constantes (preprocessing)
#define PI 3.14159
#define VELOCIDAD_LUZ 299792458
#define NOMBRE "Mi Programa"
#define MAXIMO(a,b) ((a) > (b) ? (a) : (b))

int main() {
    double radio = 5.0;
    double area = PI * radio * radio;
    
    printf("PI: %.5f\n", PI);
    printf("Velocidad de la luz: %d m/s\n", VELOCIDAD_LUZ);
    printf("Nombre: %s\n", NOMBRE);
    printf("Área del círculo: %.2f\n", area);
    printf("Máximo entre 10 y 20: %d\n", MAXIMO(10, 20));
    
    return 0;
}
```

### 5.2 Constantes con const

```c
#include <stdio.h>

int main() {
    // Variables constantes (runtime)
    const int DIAS_SEMANA = 7;
    const float GRAVEDAD = 9.81f;
    const char GRADO = 'A';
    
    printf("Días de la semana: %d\n", DIAS_SEMANA);
    printf("Gravedad: %.2f m/s²\n", GRAVEDAD);
    printf("Calificación: %c\n", GRADO);
    
    // Error si intentas modificar
    // DIAS_SEMANA = 8;  // ❌ Error de compilación
    
    return 0;
}
```

### 5.3 Constantes Literales

```c
#include <stdio.h>

int main() {
    // Constantes enteras
    int decimal = 42;
    int octal = 052;        // Prefijo 0
    int hexadecimal = 0x2A; // Prefijo 0x
    int binario = 0b101010; // Prefijo 0b (C23)
    
    // Constantes de punto flotante
    float f1 = 3.14f;       // Sufijo f
    double d1 = 3.14;       // Sin sufijo
    long double ld1 = 3.14L; // Sufijo L
    
    // Constantes de carácter
    char c1 = 'A';
    char c2 = '\n';
    char c3 = '\x41';       // Hexadecimal
    char c4 = '\101';       // Octal
    
    // Cadenas de caracteres
    char cadena[] = "Hola Mundo";
    
    printf("Enteros: %d %d %d\n", decimal, octal, hexadecimal);
    printf("Flotantes: %.2f %.2f %.2Lf\n", f1, d1, ld1);
    printf("Caracteres: %c %c %c %c\n", c1, c2, c3, c4);
    printf("Cadena: %s\n", cadena);
    
    return 0;
}
```

### 5.4 Enumeraciones

```c
#include <stdio.h>

// Definición de enumeración
enum dias_semana {
    LUNES,      // 0
    MARTES,     // 1
    MIERCOLES,  // 2
    JUEVES,     // 3
    VIERNES,    // 4
    SABADO,     // 5
    DOMINGO     // 6
};

enum meses {
    ENERO = 1,  // Empezar desde 1
    FEBRERO,    // 2
    MARZO,      // 3
    ABRIL,      // 4
    MAYO,       // 5
    JUNIO,      // 6
    JULIO,      // 7
    AGOSTO,     // 8
    SEPTIEMBRE, // 9
    OCTUBRE,    // 10
    NOVIEMBRE,  // 11
    DICIEMBRE   // 12
};

int main() {
    enum dias_semana hoy = MIERCOLES;
    enum meses mes_actual = MARZO;
    
    printf("Hoy es el día número: %d\n", hoy);
    printf("Estamos en el mes número: %d\n", mes_actual);
    
    // Uso en estructuras de control
    switch(hoy) {
        case LUNES:
        case MARTES:
        case MIERCOLES:
        case JUEVES:
        case VIERNES:
            printf("Es día laborable\n");
            break;
        case SABADO:
        case DOMINGO:
            printf("Es fin de semana\n");
            break;
    }
    
    return 0;
}
```

---

## 6. Ámbito y Duración

### 6.1 Ámbito Local (Local Scope)

```c
#include <stdio.h>

int main() {
    int variable_main = 10;
    
    printf("En main: %d\n", variable_main);
    
    {   // Nuevo bloque
        int variable_bloque = 20;
        printf("En bloque: %d\n", variable_bloque);
        printf("Acceso a main desde bloque: %d\n", variable_main);
        
        {   // Bloque anidado
            int variable_anidada = 30;
            printf("En bloque anidado: %d\n", variable_anidada);
            printf("Acceso a bloque: %d\n", variable_bloque);
            printf("Acceso a main: %d\n", variable_main);
        }
        // variable_anidada ya no existe aquí
    }
    // variable_bloque ya no existe aquí
    
    printf("De vuelta en main: %d\n", variable_main);
    
    return 0;
}
```

### 6.2 Ámbito Global (Global Scope)

```c
#include <stdio.h>

// Variables globales
int contador_global = 0;
float pi_global = 3.14159f;

void incrementar() {
    contador_global++;  // Puede acceder a variables globales
    printf("Contador en función: %d\n", contador_global);
}

void mostrar_pi() {
    printf("Pi desde función: %.5f\n", pi_global);
}

int main() {
    printf("Contador inicial: %d\n", contador_global);
    
    incrementar();
    incrementar();
    mostrar_pi();
    
    printf("Contador final: %d\n", contador_global);
    
    return 0;
}
```

### 6.3 Variables Estáticas

```c
#include <stdio.h>

void funcion_con_estatica() {
    static int contador = 0;    // Se inicializa solo una vez
    int temporal = 0;           // Se inicializa en cada llamada
    
    contador++;
    temporal++;
    
    printf("Estática: %d, Temporal: %d\n", contador, temporal);
}

int main() {
    printf("Primera llamada: ");
    funcion_con_estatica();     // Estática: 1, Temporal: 1
    
    printf("Segunda llamada: ");
    funcion_con_estatica();     // Estática: 2, Temporal: 1
    
    printf("Tercera llamada: ");
    funcion_con_estatica();     // Estática: 3, Temporal: 1
    
    return 0;
}
```

### 6.4 Ocultación de Variables (Variable Shadowing)

```c
#include <stdio.h>

int x = 100;  // Variable global

void funcion() {
    int x = 200;  // Oculta la variable global
    printf("x en función: %d\n", x);  // Imprime 200
}

int main() {
    printf("x global: %d\n", x);      // Imprime 100
    
    {
        int x = 300;  // Oculta tanto la global como la de main
        printf("x en bloque: %d\n", x);  // Imprime 300
    }
    
    printf("x en main: %d\n", x);     // Imprime 100 (global)
    
    funcion();
    
    return 0;
}
```

---

## 7. Conversión de Tipos

### 7.1 Conversión Implícita (Automática)

```c
#include <stdio.h>

int main() {
    // Jerarquía de promoción: char -> int -> float -> double
    
    char c = 'A';      // ASCII 65
    int i = 10;
    float f = 3.14f;
    double d = 2.718;
    
    // Promociones automáticas
    int resultado1 = c + i;        // char -> int
    float resultado2 = i + f;      // int -> float
    double resultado3 = f + d;     // float -> double
    
    printf("char + int: %c + %d = %d\n", c, i, resultado1);
    printf("int + float: %d + %.2f = %.2f\n", i, f, resultado2);
    printf("float + double: %.2f + %.3f = %.3f\n", f, d, resultado3);
    
    // Pérdida de precisión (conversión descendente)
    int desde_float = f;           // 3.14 -> 3
    char desde_int = i + 300;      // 310 -> 54 (overflow)
    
    printf("De float a int: %.2f -> %d\n", f, desde_float);
    printf("Overflow char: %d -> %d\n", i + 300, desde_int);
    
    return 0;
}
```

### 7.2 Conversión Explícita (Casting)

```c
#include <stdio.h>

int main() {
    // Casting explícito
    int dividendo = 10;
    int divisor = 3;
    
    // División entera vs división real
    int division_entera = dividendo / divisor;
    double division_real = (double)dividendo / divisor;
    
    printf("División entera: %d / %d = %d\n", dividendo, divisor, division_entera);
    printf("División real: %d / %d = %.6f\n", dividendo, divisor, division_real);
    
    // Casting para truncar
    double numero_decimal = 9.87654;
    int parte_entera = (int)numero_decimal;
    
    printf("Número original: %.5f\n", numero_decimal);
    printf("Parte entera: %d\n", parte_entera);
    
    // Casting entre tipos de signo
    unsigned int positivo = 4294967295U;
    int con_signo = (int)positivo;
    
    printf("Sin signo: %u\n", positivo);
    printf("Con signo: %d\n", con_signo);  // Puede ser negativo
    
    return 0;
}
```

### 7.3 Conversión de Caracteres y Números

```c
#include <stdio.h>
#include <ctype.h>

int main() {
    // Conversión carácter-número
    char digito = '7';
    int valor_numerico = digito - '0';  // '7' - '0' = 7
    
    printf("Carácter '%c' como número: %d\n", digito, valor_numerico);
    
    // Conversión número-carácter
    int numero = 5;
    char digito_char = numero + '0';    // 5 + '0' = '5'
    
    printf("Número %d como carácter: '%c'\n", numero, digito_char);
    
    // Conversión entre mayúsculas y minúsculas
    char minuscula = 'a';
    char mayuscula = minuscula - 32;    // O usar toupper()
    
    printf("Minúscula: %c -> Mayúscula: %c\n", minuscula, mayuscula);
    printf("Usando toupper(): %c\n", toupper(minuscula));
    
    // Validación de caracteres
    char test_char = 'A';
    
    if (isdigit(test_char)) {
        printf("'%c' es un dígito\n", test_char);
    } else if (isalpha(test_char)) {
        printf("'%c' es una letra\n", test_char);
        if (isupper(test_char)) {
            printf("'%c' es mayúscula\n", test_char);
        }
    }
    
    return 0;
}
```

---

## 8. Tipos Derivados

### 8.1 Arreglos (Arrays)

```c
#include <stdio.h>

int main() {
    // Declaración e inicialización de arreglos
    int numeros[5] = {1, 2, 3, 4, 5};
    float temperaturas[] = {23.5f, 25.2f, 22.1f, 24.8f};  // Tamaño inferido
    char vocales[5] = {'a', 'e', 'i', 'o', 'u'};
    
    // Acceso a elementos
    printf("Primer número: %d\n", numeros[0]);
    printf("Última temperatura: %.1f\n", temperaturas[3]);
    
    // Modificación de elementos
    numeros[2] = 30;
    temperaturas[1] = 26.0f;
    
    // Recorrido con bucle
    printf("Números: ");
    for (int i = 0; i < 5; i++) {
        printf("%d ", numeros[i]);
    }
    printf("\n");
    
    printf("Temperaturas: ");
    for (int i = 0; i < 4; i++) {
        printf("%.1f ", temperaturas[i]);
    }
    printf("\n");
    
    // Tamaño del arreglo
    int tamaño_numeros = sizeof(numeros) / sizeof(numeros[0]);
    printf("Tamaño del arreglo números: %d elementos\n", tamaño_numeros);
    
    return 0;
}
```

### 8.2 Cadenas de Caracteres (Strings)

```c
#include <stdio.h>
#include <string.h>

int main() {
    // Diferentes formas de declarar cadenas
    char nombre1[] = "Juan";           // Arreglo con tamaño automático
    char nombre2[10] = "María";        // Arreglo con tamaño específico
    char nombre3[20];                  // Arreglo sin inicializar
    
    // Inicialización posterior
    strcpy(nombre3, "Pedro");
    
    printf("Nombre 1: %s\n", nombre1);
    printf("Nombre 2: %s\n", nombre2);
    printf("Nombre 3: %s\n", nombre3);
    
    // Operaciones con cadenas
    char apellido[] = "González";
    char nombre_completo[50];
    
    // Concatenación
    strcpy(nombre_completo, nombre1);
    strcat(nombre_completo, " ");
    strcat(nombre_completo, apellido);
    
    printf("Nombre completo: %s\n", nombre_completo);
    
    // Longitud de cadena
    int longitud = strlen(nombre_completo);
    printf("Longitud: %d caracteres\n", longitud);
    
    // Comparación de cadenas
    if (strcmp(nombre1, "Juan") == 0) {
        printf("El nombre es Juan\n");
    }
    
    return 0;
}
```

### 8.3 Punteros (Pointers)

```c
#include <stdio.h>

int main() {
    // Variables normales
    int numero = 42;
    float precio = 19.99f;
    char letra = 'A';
    
    // Declaración de punteros
    int *ptr_numero = &numero;        // Puntero a int
    float *ptr_precio = &precio;      // Puntero a float
    char *ptr_letra = &letra;         // Puntero a char
    
    // Mostrar direcciones y valores
    printf("=== VARIABLES ORIGINALES ===\n");
    printf("numero: %d (dirección: %p)\n", numero, (void*)&numero);
    printf("precio: %.2f (dirección: %p)\n", precio, (void*)&precio);
    printf("letra: %c (dirección: %p)\n", letra, (void*)&letra);
    
    printf("\n=== PUNTEROS ===\n");
    printf("ptr_numero apunta a: %p\n", (void*)ptr_numero);
    printf("Valor apuntado: %d\n", *ptr_numero);
    
    printf("ptr_precio apunta a: %p\n", (void*)ptr_precio);
    printf("Valor apuntado: %.2f\n", *ptr_precio);
    
    printf("ptr_letra apunta a: %p\n", (void*)ptr_letra);
    printf("Valor apuntado: %c\n", *ptr_letra);
    
    // Modificar valores a través de punteros
    *ptr_numero = 100;
    *ptr_precio = 25.50f;
    *ptr_letra = 'Z';
    
    printf("\n=== DESPUÉS DE MODIFICAR ===\n");
    printf("numero: %d\n", numero);
    printf("precio: %.2f\n", precio);
    printf("letra: %c\n", letra);
    
    return 0;
}
```

### 8.4 Estructuras (Structs)

```c
#include <stdio.h>
#include <string.h>

// Definición de estructura
struct Persona {
    char nombre[50];
    int edad;
    float altura;
    char genero;
};

// Definición con typedef
typedef struct {
    int x;
    int y;
} Punto;

int main() {
    // Declaración e inicialización
    struct Persona persona1 = {"Ana García", 28, 1.65f, 'F'};
    
    struct Persona persona2;
    strcpy(persona2.nombre, "Carlos López");
    persona2.edad = 35;
    persona2.altura = 1.80f;
    persona2.genero = 'M';
    
    // Uso con typedef
    Punto coordenada = {10, 20};
    
    // Acceso a miembros
    printf("=== PERSONA 1 ===\n");
    printf("Nombre: %s\n", persona1.nombre);
    printf("Edad: %d años\n", persona1.edad);
    printf("Altura: %.2f metros\n", persona1.altura);
    printf("Género: %c\n", persona1.genero);
    
    printf("\n=== PERSONA 2 ===\n");
    printf("Nombre: %s\n", persona2.nombre);
    printf("Edad: %d años\n", persona2.edad);
    printf("Altura: %.2f metros\n", persona2.altura);
    printf("Género: %c\n", persona2.genero);
    
    printf("\n=== PUNTO ===\n");
    printf("Coordenadas: (%d, %d)\n", coordenada.x, coordenada.y);
    
    // Modificar valores
    persona1.edad++;
    coordenada.x += 5;
    
    printf("\n=== DESPUÉS DE MODIFICAR ===\n");
    printf("%s ahora tiene %d años\n", persona1.nombre, persona1.edad);
    printf("Nueva coordenada x: %d\n", coordenada.x);
    
    return 0;
}
```

### 8.5 Uniones (Unions)

```c
#include <stdio.h>

// Definición de unión
union Datos {
    int entero;
    float flotante;
    char caracter;
};

int main() {
    union Datos dato;
    
    printf("Tamaño de la unión: %zu bytes\n", sizeof(dato));
    
    // Almacenar un entero
    dato.entero = 42;
    printf("Como entero: %d\n", dato.entero);
    printf("Como float: %.2f (basura)\n", dato.flotante);
    printf("Como char: %c (basura)\n", dato.caracter);
    
    printf("\n");
    
    // Almacenar un float
    dato.flotante = 3.14f;
    printf("Como float: %.2f\n", dato.flotante);
    printf("Como entero: %d (basura)\n", dato.entero);
    printf("Como char: %c (basura)\n", dato.caracter);
    
    printf("\n");
    
    // Almacenar un carácter
    dato.caracter = 'A';
    printf("Como char: %c\n", dato.caracter);
    printf("Como entero: %d\n", dato.entero);  // Mostrará valor ASCII
    printf("Como float: %.2f (basura)\n", dato.flotante);
    
    return 0;
}
```

---

## 9. Buenas Prácticas

### 9.1 Convenciones de Nomenclatura

```c
#include <stdio.h>

// Constantes en MAYÚSCULAS
#define MAX_ESTUDIANTES 100
#define PI 3.14159

// Variables globales con prefijo g_
int g_contador_global = 0;

// Funciones con nombres descriptivos
int calcular_area_rectangulo(int ancho, int alto);
void mostrar_menu_principal(void);

int main() {
    // Variables locales en minúsculas con snake_case
    int numero_estudiantes = 0;
    float promedio_calificaciones = 0.0f;
    char nombre_archivo[50];
    
    // O usar camelCase (consistente en todo el proyecto)
    int numeroEstudiantes = 0;
    float promedioCalificaciones = 0.0f;
    char nombreArchivo[50];
    
    // Variables booleanas con prefijos is_, has_, can_
    int is_valido = 1;      // 1 para true, 0 para false
    int has_datos = 0;
    int can_procesar = 1;
    
    // Constantes locales con const
    const int DIAS_MES = 30;
    const float DESCUENTO = 0.15f;
    
    return 0;
}
```

### 9.2 Inicialización de Variables

```c
#include <stdio.h>

int main() {
    // ✅ BUENAS PRÁCTICAS
    
    // Siempre inicializar variables
    int contador = 0;
    float precio = 0.0f;
    char inicial = '\0';
    
    // Inicializar en el momento de declaración
    int edad = 25;
    float altura = 1.75f;
    
    // Para arreglos, inicializar completamente o usar {0}
    int numeros[10] = {0};  // Todos los elementos en 0
    char buffer[100] = {0}; // Todo el buffer en 0
    
    // ❌ MALAS PRÁCTICAS
    
    // No declarar sin inicializar
    // int sin_inicializar;           // ❌ Valor impredecible
    // printf("%d\n", sin_inicializar); // ❌ Comportamiento indefinido
    
    // No asumir valores iniciales en variables automáticas
    // int asume_cero;                // ❌ No está garantizado
    
    return 0;
}
```

### 9.3 Uso Apropiado de Tipos

```c
#include <stdio.h>

int main() {
    // ✅ Elegir el tipo apropiado para el uso
    
    // Para contadores que no pueden ser negativos
    unsigned int contador_positivo = 0;
    
    // Para valores que pueden ser muy grandes
    long long numero_muy_grande = 9223372036854775807LL;
    
    // Para cálculos que requieren precisión
    double calculo_preciso = 1.0 / 3.0;
    
    // Para optimizar memoria en estructuras grandes
    struct ConfiguracionCompacta {
        unsigned char flags;     // 8 bits para 8 banderas
        short puerto;           // Suficiente para números de puerto
        int direccion_ip;       // 32 bits para IPv4
    };
    
    // Para caracteres que representan datos binarios
    unsigned char byte_datos = 0xFF;
    
    // ✅ Usar const para valores que no cambian
    const double GRAVEDAD = 9.81;
    const int MAX_INTENTOS = 3;
    
    printf("Gravedad: %.2f\n", GRAVEDAD);
    printf("Máximo intentos: %d\n", MAX_INTENTOS);
    
    return 0;
}
```

### 9.4 Gestión de Memoria y Recursos

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // ✅ Gestión apropiada de memoria dinámica
    
    int *numeros = malloc(10 * sizeof(int));
    if (numeros == NULL) {
        fprintf(stderr, "Error: No se pudo asignar memoria\n");
        return 1;
    }
    
    // Inicializar la memoria asignada
    for (int i = 0; i < 10; i++) {
        numeros[i] = i * i;
    }
    
    // Usar la memoria
    printf("Números: ");
    for (int i = 0; i < 10; i++) {
        printf("%d ", numeros[i]);
    }
    printf("\n");
    
    // ✅ Siempre liberar la memoria
    free(numeros);
    numeros = NULL;  // Evitar uso accidental posterior
    
    // ✅ Manejo de archivos con verificación
    FILE *archivo = fopen("datos.txt", "w");
    if (archivo != NULL) {
        fprintf(archivo, "Datos de prueba\n");
        fclose(archivo);  // Siempre cerrar archivos
    } else {
        fprintf(stderr, "Error: No se pudo abrir el archivo\n");
    }
    
    return 0;
}
```

---

## 10. Ejercicios Prácticos

### 10.1 Ejercicios Básicos

#### Ejercicio 1: Calculadora Simple
```c
#include <stdio.h>

int main() {
    // Declarar variables para los operandos y resultado
    float numero1, numero2, resultado;
    char operador;
    
    // Solicitar datos al usuario
    printf("Ingrese el primer número: ");
    scanf("%f", &numero1);
    
    printf("Ingrese la operación (+, -, *, /): ");
    scanf(" %c", &operador);  // Espacio antes de %c para ignorar whitespace
    
    printf("Ingrese el segundo número: ");
    scanf("%f", &numero2);
    
    // Realizar la operación según el operador
    switch (operador) {
        case '+':
            resultado = numero1 + numero2;
            printf("%.2f + %.2f = %.2f\n", numero1, numero2, resultado);
            break;
        case '-':
            resultado = numero1 - numero2;
            printf("%.2f - %.2f = %.2f\n", numero1, numero2, resultado);
            break;
        case '*':
            resultado = numero1 * numero2;
            printf("%.2f * %.2f = %.2f\n", numero1, numero2, resultado);
            break;
        case '/':
            if (numero2 != 0) {
                resultado = numero1 / numero2;
                printf("%.2f / %.2f = %.2f\n", numero1, numero2, resultado);
            } else {
                printf("Error: División por cero\n");
            }
            break;
        default:
            printf("Error: Operador no válido\n");
    }
    
    return 0;
}
```

#### Ejercicio 2: Conversor de Temperaturas
```c
#include <stdio.h>

int main() {
    float temperatura, resultado;
    int opcion;
    
    printf("=== CONVERSOR DE TEMPERATURAS ===\n");
    printf("1. Celsius a Fahrenheit\n");
    printf("2. Fahrenheit a Celsius\n");
    printf("3. Celsius a Kelvin\n");
    printf("4. Kelvin a Celsius\n");
    printf("Seleccione una opción (1-4): ");
    scanf("%d", &opcion);
    
    printf("Ingrese la temperatura: ");
    scanf("%f", &temperatura);
    
    switch (opcion) {
        case 1:  // Celsius a Fahrenheit
            resultado = (temperatura * 9.0f / 5.0f) + 32.0f;
            printf("%.2f°C = %.2f°F\n", temperatura, resultado);
            break;
        case 2:  // Fahrenheit a Celsius
            resultado = (temperatura - 32.0f) * 5.0f / 9.0f;
            printf("%.2f°F = %.2f°C\n", temperatura, resultado);
            break;
        case 3:  // Celsius a Kelvin
            resultado = temperatura + 273.15f;
            printf("%.2f°C = %.2fK\n", temperatura, resultado);
            break;
        case 4:  // Kelvin a Celsius
            resultado = temperatura - 273.15f;
            printf("%.2fK = %.2f°C\n", temperatura, resultado);
            break;
        default:
            printf("Opción no válida\n");
    }
    
    return 0;
}
```

### 10.2 Ejercicios Intermedios

#### Ejercicio 3: Sistema de Calificaciones
```c
#include <stdio.h>

struct Estudiante {
    char nombre[50];
    int edad;
    float calificaciones[5];
    float promedio;
    char letra_calificacion;
};

char calcular_letra_calificacion(float promedio) {
    if (promedio >= 90) return 'A';
    else if (promedio >= 80) return 'B';
    else if (promedio >= 70) return 'C';
    else if (promedio >= 60) return 'D';
    else return 'F';
}

int main() {
    struct Estudiante estudiante;
    float suma = 0.0f;
    
    // Solicitar datos del estudiante
    printf("Ingrese el nombre del estudiante: ");
    scanf("%s", estudiante.nombre);
    
    printf("Ingrese la edad: ");
    scanf("%d", &estudiante.edad);
    
    printf("Ingrese 5 calificaciones:\n");
    for (int i = 0; i < 5; i++) {
        printf("Calificación %d: ", i + 1);
        scanf("%f", &estudiante.calificaciones[i]);
        suma += estudiante.calificaciones[i];
    }
    
    // Calcular promedio y letra de calificación
    estudiante.promedio = suma / 5.0f;
    estudiante.letra_calificacion = calcular_letra_calificacion(estudiante.promedio);
    
    // Mostrar resultados
    printf("\n=== REPORTE DEL ESTUDIANTE ===\n");
    printf("Nombre: %s\n", estudiante.nombre);
    printf("Edad: %d años\n", estudiante.edad);
    printf("Calificaciones: ");
    for (int i = 0; i < 5; i++) {
        printf("%.1f ", estudiante.calificaciones[i]);
    }
    printf("\nPromedio: %.2f\n", estudiante.promedio);
    printf("Calificación: %c\n", estudiante.letra_calificacion);
    
    // Determinar estado
    if (estudiante.promedio >= 60) {
        printf("Estado: APROBADO\n");
    } else {
        printf("Estado: REPROBADO\n");
    }
    
    return 0;
}
```

#### Ejercicio 4: Análisis de Datos Numéricos
```c
#include <stdio.h>

#define MAX_NUMEROS 100

int main() {
    int numeros[MAX_NUMEROS];
    int cantidad;
    int suma = 0;
    float promedio;
    int minimo, maximo;
    int contador_pares = 0, contador_impares = 0;
    
    // Solicitar cantidad de números
    printf("¿Cuántos números desea ingresar? (máximo %d): ", MAX_NUMEROS);
    scanf("%d", &cantidad);
    
    if (cantidad <= 0 || cantidad > MAX_NUMEROS) {
        printf("Cantidad no válida\n");
        return 1;
    }
    
    // Ingresar números
    printf("Ingrese los %d números:\n", cantidad);
    for (int i = 0; i < cantidad; i++) {
        printf("Número %d: ", i + 1);
        scanf("%d", &numeros[i]);
        
        // Acumular suma
        suma += numeros[i];
        
        // Encontrar mínimo y máximo
        if (i == 0) {
            minimo = maximo = numeros[i];
        } else {
            if (numeros[i] < minimo) minimo = numeros[i];
            if (numeros[i] > maximo) maximo = numeros[i];
        }
        
        // Contar pares e impares
        if (numeros[i] % 2 == 0) {
            contador_pares++;
        } else {
            contador_impares++;
        }
    }
    
    // Calcular promedio
    promedio = (float)suma / cantidad;
    
    // Mostrar resultados
    printf("\n=== ANÁLISIS DE DATOS ===\n");
    printf("Cantidad de números: %d\n", cantidad);
    printf("Suma total: %d\n", suma);
    printf("Promedio: %.2f\n", promedio);
    printf("Número mínimo: %d\n", minimo);
    printf("Número máximo: %d\n", maximo);
    printf("Números pares: %d\n", contador_pares);
    printf("Números impares: %d\n", contador_impares);
    
    // Mostrar números mayores al promedio
    printf("\nNúmeros mayores al promedio:\n");
    for (int i = 0; i < cantidad; i++) {
        if (numeros[i] > promedio) {
            printf("%d ", numeros[i]);
        }
    }
    printf("\n");
    
    return 0;
}
```

---

## 11. Conceptos Avanzados

### 11.1 Punteros a Funciones

```c
#include <stdio.h>

// Funciones matemáticas simples
int sumar(int a, int b) {
    return a + b;
}

int restar(int a, int b) {
    return a - b;
}

int multiplicar(int a, int b) {
    return a * b;
}

// Función que usa punteros a función
int calcular(int x, int y, int (*operacion)(int, int)) {
    return operacion(x, y);
}

int main() {
    // Declaración de punteros a función
    int (*ptr_operacion)(int, int);
    
    int a = 10, b = 5;
    
    // Asignar diferentes funciones al puntero
    ptr_operacion = sumar;
    printf("Suma: %d + %d = %d\n", a, b, ptr_operacion(a, b));
    
    ptr_operacion = restar;
    printf("Resta: %d - %d = %d\n", a, b, ptr_operacion(a, b));
    
    ptr_operacion = multiplicar;
    printf("Multiplicación: %d * %d = %d\n", a, b, ptr_operacion(a, b));
    
    // Usar función que recibe puntero a función
    printf("\nUsando función calcular:\n");
    printf("Suma: %d\n", calcular(a, b, sumar));
    printf("Resta: %d\n", calcular(a, b, restar));
    printf("Multiplicación: %d\n", calcular(a, b, multiplicar));
    
    return 0;
}
```

### 11.2 Memoria Dinámica Avanzada

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estructura para lista dinámica
struct Nodo {
    int dato;
    struct Nodo *siguiente;
};

// Función para crear un nuevo nodo
struct Nodo* crear_nodo(int valor) {
    struct Nodo *nuevo = malloc(sizeof(struct Nodo));
    if (nuevo != NULL) {
        nuevo->dato = valor;
        nuevo->siguiente = NULL;
    }
    return nuevo;
}

// Función para agregar al inicio de la lista
struct Nodo* agregar_inicio(struct Nodo *cabeza, int valor) {
    struct Nodo *nuevo = crear_nodo(valor);
    if (nuevo != NULL) {
        nuevo->siguiente = cabeza;
        return nuevo;
    }
    return cabeza;
}

// Función para mostrar la lista
void mostrar_lista(struct Nodo *cabeza) {
    struct Nodo *actual = cabeza;
    printf("Lista: ");
    while (actual != NULL) {
        printf("%d -> ", actual->dato);
        actual = actual->siguiente;
    }
    printf("NULL\n");
}

// Función para liberar memoria de la lista
void liberar_lista(struct Nodo *cabeza) {
    struct Nodo *actual = cabeza;
    struct Nodo *siguiente;
    
    while (actual != NULL) {
        siguiente = actual->siguiente;
        free(actual);
        actual = siguiente;
    }
}

int main() {
    struct Nodo *lista = NULL;
    
    // Agregar elementos a la lista
    lista = agregar_inicio(lista, 10);
    lista = agregar_inicio(lista, 20);
    lista = agregar_inicio(lista, 30);
    lista = agregar_inicio(lista, 40);
    
    // Mostrar la lista
    mostrar_lista(lista);
    
    // Liberar memoria
    liberar_lista(lista);
    
    printf("Memoria liberada correctamente\n");
    
    return 0;
}
```

### 11.3 Manipulación Avanzada de Bits

```c
#include <stdio.h>

// Función para mostrar representación binaria
void mostrar_bits(unsigned int numero) {
    int bits = sizeof(unsigned int) * 8;
    printf("Binario: ");
    
    for (int i = bits - 1; i >= 0; i--) {
        int bit = (numero >> i) & 1;
        printf("%d", bit);
        if (i % 4 == 0 && i > 0) printf(" ");  // Separador cada 4 bits
    }
    printf(" (decimal: %u)\n", numero);
}

int main() {
    unsigned int numero = 45;  // 00101101 en binario
    
    printf("=== OPERACIONES DE BITS ===\n");
    printf("Número original: %u\n", numero);
    mostrar_bits(numero);
    
    // Operación AND
    unsigned int mascara_and = 0x0F;  // 00001111
    unsigned int resultado_and = numero & mascara_and;
    printf("\nOperación AND con 0x0F:\n");
    mostrar_bits(resultado_and);
    
    // Operación OR
    unsigned int mascara_or = 0xF0;   // 11110000
    unsigned int resultado_or = numero | mascara_or;
    printf("\nOperación OR con 0xF0:\n");
    mostrar_bits(resultado_or);
    
    // Operación XOR
    unsigned int mascara_xor = 0xFF;  // 11111111
    unsigned int resultado_xor = numero ^ mascara_xor;
    printf("\nOperación XOR con 0xFF:\n");
    mostrar_bits(resultado_xor);
    
    // Desplazamiento a la izquierda
    unsigned int desplaz_izq = numero << 2;
    printf("\nDesplazamiento izquierda (<<2):\n");
    mostrar_bits(desplaz_izq);
    
    // Desplazamiento a la derecha
    unsigned int desplaz_der = numero >> 2;
    printf("\nDesplazamiento derecha (>>2):\n");
    mostrar_bits(desplaz_der);
    
    // Ejemplos prácticos
    printf("\n=== APLICACIONES PRÁCTICAS ===\n");
    
    // Verificar si un bit específico está activado
    int bit_posicion = 3;
    if (numero & (1 << bit_posicion)) {
        printf("El bit %d está activado\n", bit_posicion);
    } else {
        printf("El bit %d está desactivado\n", bit_posicion);
    }
    
    // Activar un bit específico
    unsigned int activar_bit = numero | (1 << 1);
    printf("Activando bit 1:\n");
    mostrar_bits(activar_bit);
    
    // Desactivar un bit específico
    unsigned int desactivar_bit = numero & ~(1 << 3);
    printf("Desactivando bit 3:\n");
    mostrar_bits(desactivar_bit);
    
    // Alternar un bit específico
    unsigned int alternar_bit = numero ^ (1 << 2);
    printf("Alternando bit 2:\n");
    mostrar_bits(alternar_bit);
    
    return 0;
}
```

---

## 12. Debugging y Herramientas

### 12.1 Técnicas de Debugging

```c
#include <stdio.h>
#include <assert.h>

// Macro para debugging condicional
#ifdef DEBUG
    #define DBG_PRINT(fmt, ...) printf("[DEBUG] " fmt, ##__VA_ARGS__)
#else
    #define DBG_PRINT(fmt, ...)
#endif

int dividir(int dividendo, int divisor) {
    // Uso de assert para verificar precondiciones
    assert(divisor != 0);
    
    DBG_PRINT("Dividiendo %d entre %d\n", dividendo, divisor);
    
    int resultado = dividendo / divisor;
    
    DBG_PRINT("Resultado: %d\n", resultado);
    
    return resultado;
}

void mostrar_array_debug(int arr[], int tamaño, const char *nombre) {
    printf("[DEBUG] Array %s: [", nombre);
    for (int i = 0; i < tamaño; i++) {
        printf("%d", arr[i]);
        if (i < tamaño - 1) printf(", ");
    }
    printf("]\n");
}

int main() {
    printf("=== EJEMPLO DE DEBUGGING ===\n");
    
    // Variables para prueba
    int numeros[] = {5, 10, 15, 20, 25};
    int tamaño = sizeof(numeros) / sizeof(numeros[0]);
    
    // Mostrar estado inicial
    mostrar_array_debug(numeros, tamaño, "numeros");
    
    // Operaciones con logging
    int resultado1 = dividir(20, 4);
    printf("20 / 4 = %d\n", resultado1);
    
    int resultado2 = dividir(15, 3);
    printf("15 / 3 = %d\n", resultado2);
    
    // Ejemplo de verificación de límites
    int indice = 2;
    if (indice >= 0 && indice < tamaño) {
        printf("Elemento en índice %d: %d\n", indice, numeros[indice]);
    } else {
        printf("Error: Índice %d fuera de límites\n", indice);
    }
    
    // Prueba de assert (descomenta para probar)
    // dividir(10, 0);  // Esto causaría una falla de assert
    
    return 0;
}
```

### 12.2 Herramientas de Análisis

#### Uso de Valgrind (Linux/Mac)
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Programa con problemas de memoria para demostrar Valgrind
void ejemplo_memory_leak() {
    int *ptr = malloc(100 * sizeof(int));
    
    // Inicializar algunos valores
    for (int i = 0; i < 100; i++) {
        ptr[i] = i * i;
    }
    
    // ❌ Memory leak: no se llama a free()
    // free(ptr);  // Descomenta esta línea para corregir
}

void ejemplo_buffer_overflow() {
    char buffer[10];
    
    // ❌ Buffer overflow potencial
    strcpy(buffer, "Esta cadena es muy larga para el buffer");
    
    // ✅ Versión segura
    // strncpy(buffer, "Seguro", sizeof(buffer) - 1);
    // buffer[sizeof(buffer) - 1] = '\0';
    
    printf("Buffer: %s\n", buffer);
}

void ejemplo_use_after_free() {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;
    
    printf("Valor: %d\n", *ptr);
    free(ptr);
    
    // ❌ Use after free
    // printf("Valor después de free: %d\n", *ptr);
}

int main() {
    printf("=== EJEMPLO PARA VALGRIND ===\n");
    
    // Para ejecutar con Valgrind:
    // valgrind --leak-check=full ./programa
    
    ejemplo_memory_leak();
    // ejemplo_buffer_overflow();  // Descomenta para probar
    // ejemplo_use_after_free();   // Descomenta para probar
    
    printf("Programa terminado\n");
    
    return 0;
}
```

### 12.3 Logging y Monitoreo

```c
#include <stdio.h>
#include <time.h>
#include <stdarg.h>

// Niveles de logging
typedef enum {
    LOG_DEBUG,
    LOG_INFO,
    LOG_WARNING,
    LOG_ERROR
} LogLevel;

// Función de logging con timestamp
void log_message(LogLevel level, const char *formato, ...) {
    // Obtener timestamp
    time_t tiempo_actual = time(NULL);
    struct tm *tiempo_local = localtime(&tiempo_actual);
    
    // Prefijos por nivel
    const char *prefijos[] = {"DEBUG", "INFO", "WARN", "ERROR"};
    
    // Imprimir timestamp y nivel
    printf("[%02d:%02d:%02d %s] ", 
           tiempo_local->tm_hour,
           tiempo_local->tm_min,
           tiempo_local->tm_sec,
           prefijos[level]);
    
    // Imprimir mensaje con argumentos variables
    va_list args;
    va_start(args, formato);
    vprintf(formato, args);
    va_end(args);
    
    printf("\n");
}

// Función que simula procesamiento con logging
int procesar_datos(int *datos, int cantidad) {
    log_message(LOG_INFO, "Iniciando procesamiento de %d elementos", cantidad);
    
    if (datos == NULL) {
        log_message(LOG_ERROR, "Puntero de datos es NULL");
        return -1;
    }
    
    if (cantidad <= 0) {
        log_message(LOG_WARNING, "Cantidad de elementos no válida: %d", cantidad);
        return 0;
    }
    
    int procesados = 0;
    for (int i = 0; i < cantidad; i++) {
        log_message(LOG_DEBUG, "Procesando elemento %d: valor = %d", i, datos[i]);
        
        // Simular algún procesamiento
        if (datos[i] < 0) {
            log_message(LOG_WARNING, "Valor negativo encontrado en posición %d", i);
        }
        
        datos[i] *= 2;  // Duplicar el valor
        procesados++;
    }
    
    log_message(LOG_INFO, "Procesamiento completado. Elementos procesados: %d", procesados);
    return procesados;
}

int main() {
    printf("=== SISTEMA DE LOGGING ===\n");
    
    int numeros[] = {1, -5, 10, 0, 25, -3};
    int cantidad = sizeof(numeros) / sizeof(numeros[0]);
    
    log_message(LOG_INFO, "Programa iniciado");
    
    // Mostrar datos originales
    printf("Datos originales: ");
    for (int i = 0; i < cantidad; i++) {
        printf("%d ", numeros[i]);
    }
    printf("\n");
    
    // Procesar datos con logging
    int resultado = procesar_datos(numeros, cantidad);
    
    if (resultado > 0) {
        // Mostrar datos procesados
        printf("Datos procesados: ");
        for (int i = 0; i < cantidad; i++) {
            printf("%d ", numeros[i]);
        }
        printf("\n");
        
        log_message(LOG_INFO, "Proceso exitoso");
    } else {
        log_message(LOG_ERROR, "Error en el procesamiento");
    }
    
    log_message(LOG_INFO, "Programa terminado");
    
    return 0;
}
```

---

## 13. Resumen y Mejores Prácticas

### 13.1 Checklist de Buenas Prácticas

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ✅ MEJORES PRÁCTICAS RESUMIDAS

// 1. Siempre incluir headers necesarios
#include <stdio.h>    // Para printf, scanf
#include <stdlib.h>   // Para malloc, free
#include <string.h>   // Para strcpy, strlen

// 2. Usar constantes con nombres descriptivos
#define MAX_NOMBRE 50
#define MAX_ESTUDIANTES 100
#define PI 3.14159

// 3. Declarar estructuras con nombres claros
typedef struct {
    char nombre[MAX_NOMBRE];
    int edad;
    float promedio;
} Estudiante;

// 4. Funciones con un propósito específico
int validar_edad(int edad) {
    return (edad >= 0 && edad <= 150);
}

void inicializar_estudiante(Estudiante *est) {
    if (est != NULL) {
        strcpy(est->nombre, "");
        est->edad = 0;
        est->promedio = 0.0f;
    }
}

void mostrar_estudiante(const Estudiante *est) {
    if (est != NULL) {
        printf("Nombre: %s, Edad: %d, Promedio: %.2f\n", 
               est->nombre, est->edad, est->promedio);
    }
}

int main() {
    printf("=== MEJORES PRÁCTICAS EN C ===\n");
    
    // ✅ Inicializar todas las variables
    int contador = 0;
    float suma = 0.0f;
    
    // ✅ Verificar límites de arreglos
    Estudiante estudiantes[MAX_ESTUDIANTES];
    int num_estudiantes = 0;
    
    // ✅ Inicializar estructuras
    for (int i = 0; i < MAX_ESTUDIANTES; i++) {
        inicializar_estudiante(&estudiantes[i]);
    }
    
    // ✅ Validar entrada de usuario
    int edad_entrada;
    printf("Ingrese edad: ");
    if (scanf("%d", &edad_entrada) == 1 && validar_edad(edad_entrada)) {
        printf("Edad válida: %d\n", edad_entrada);
    } else {
        printf("Edad no válida\n");
        return 1;
    }
    
    // ✅ Crear un estudiante de ejemplo
    Estudiante estudiante_ejemplo;
    strcpy(estudiante_ejemplo.nombre, "Juan Pérez");
    estudiante_ejemplo.edad = edad_entrada;
    estudiante_ejemplo.promedio = 85.5f;
    
    mostrar_estudiante(&estudiante_ejemplo);
    
    // ✅ Usar const para valores que no cambian
    const int LIMITE_SUPERIOR = 100;
    if (estudiante_ejemplo.promedio <= LIMITE_SUPERIOR) {
        printf("Promedio dentro del rango permitido\n");
    }
    
    return 0;
}
```

### 13.2 Errores Comunes y Como Evitarlos

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void ejemplos_errores_comunes() {
    printf("=== ERRORES COMUNES Y SOLUCIONES ===\n");
    
    // ❌ ERROR 1: Variables no inicializadas
    /*
    int variable_peligrosa;
    printf("Valor: %d\n", variable_peligrosa);  // Valor impredecible!
    */
    
    // ✅ SOLUCIÓN: Siempre inicializar
    int variable_segura = 0;
    printf("Valor inicializado: %d\n", variable_segura);
    
    // ❌ ERROR 2: Desbordamiento de buffer
    /*
    char buffer_pequeño[5];
    strcpy(buffer_pequeño, "Texto muy largo");  // Buffer overflow!
    */
    
    // ✅ SOLUCIÓN: Usar funciones seguras y verificar tamaños
    char buffer_seguro[20];
    strncpy(buffer_seguro, "Texto seguro", sizeof(buffer_seguro) - 1);
    buffer_seguro[sizeof(buffer_seguro) - 1] = '\0';
    printf("Buffer seguro: %s\n", buffer_seguro);
    
    // ❌ ERROR 3: Memory leak
    /*
    int *ptr_problema = malloc(10 * sizeof(int));
    // ... usar ptr_problema ...
    // Olvidar: free(ptr_problema);
    */
    
    // ✅ SOLUCIÓN: Siempre emparejar malloc con free
    int *ptr_correcto = malloc(10 * sizeof(int));
    if (ptr_correcto != NULL) {
        // Usar el puntero
        ptr_correcto[0] = 42;
        printf("Valor asignado: %d\n", ptr_correcto[0]);
        
        // Liberar memoria
        free(ptr_correcto);
        ptr_correcto = NULL;  // Evitar uso posterior
    }
    
    // ❌ ERROR 4: División por cero
    /*
    int a = 10, b = 0;
    int resultado = a / b;  // Error en tiempo de ejecución!
    */
    
    // ✅ SOLUCIÓN: Verificar divisor antes de dividir
    int dividendo = 10, divisor = 0;
    if (divisor != 0) {
        int resultado = dividendo / divisor;
        printf("Resultado: %d\n", resultado);
    } else {
        printf("Error: No se puede dividir por cero\n");
    }
    
    // ❌ ERROR 5: Acceso fuera de límites de arreglo
    /*
    int arreglo[5] = {1, 2, 3, 4, 5};
    int valor = arreglo[10];  // Acceso fuera de límites!
    */
    
    // ✅ SOLUCIÓN: Verificar índices
    int arreglo_seguro[5] = {1, 2, 3, 4, 5};
    int indice = 3;
    if (indice >= 0 && indice < 5) {
        printf("Valor en índice %d: %d\n", indice, arreglo_seguro[indice]);
    } else {
        printf("Índice fuera de límites\n");
    }
}

int main() {
    ejemplos_errores_comunes();
    return 0;
}
```

### 13.3 Optimizaciones y Rendimiento

```c
#include <stdio.h>
#include <time.h>

// Función para medir tiempo de ejecución
double medir_tiempo(clock_t inicio, clock_t fin) {
    return ((double)(fin - inicio)) / CLOCKS_PER_SEC;
}

// ❌ Versión ineficiente
int busqueda_lineal_ineficiente(int arr[], int n, int objetivo) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == objetivo) {
            return i;  // Encontrado
        }
    }
    return -1;  // No encontrado
}

// ✅ Versión optimizada (para arreglos ordenados)
int busqueda_binaria(int arr[], int n, int objetivo) {
    int izquierda = 0;
    int derecha = n - 1;
    
    while (izquierda <= derecha) {
        int medio = izquierda + (derecha - izquierda) / 2;
        
        if (arr[medio] == objetivo) {
            return medio;
        }
        
        if (arr[medio] < objetivo) {
            izquierda = medio + 1;
        } else {
            derecha = medio - 1;
        }
    }
    
    return -1;  // No encontrado
}

// Ejemplo de optimización de memoria
void ejemplo_optimizacion_memoria() {
    printf("\n=== OPTIMIZACIÓN DE MEMORIA ===\n");
    
    // ❌ Estructura no optimizada
    struct PuntoIneficiente {
        char flag;      // 1 byte
        double x;       // 8 bytes
        char otro_flag; // 1 byte
        double y;       // 8 bytes
    };  // Total: puede ser 24+ bytes debido al padding
    
    // ✅ Estructura optimizada
    struct PuntoEficiente {
        double x;       // 8 bytes
        double y;       // 8 bytes
        char flag;      // 1 byte
        char otro_flag; // 1 byte
    };  // Total: 18 bytes + padding mínimo
    
    printf("Tamaño PuntoIneficiente: %zu bytes\n", sizeof(struct PuntoIneficiente));
    printf("Tamaño PuntoEficiente: %zu bytes\n", sizeof(struct PuntoEficiente));
}

int main() {
    printf("=== OPTIMIZACIÓN Y RENDIMIENTO ===\n");
    
    // Crear arreglo de prueba (ordenado para búsqueda binaria)
    const int TAMAÑO = 100000;
    int *arreglo = malloc(TAMAÑO * sizeof(int));
    
    if (arreglo == NULL) {
        printf("Error al asignar memoria\n");
        return 1;
    }
    
    // Llenar arreglo con números ordenados
    for (int i = 0; i < TAMAÑO; i++) {
        arreglo[i] = i * 2;  // 0, 2, 4, 6, 8, ...
    }
    
    int objetivo = 50000;  // Buscar este número
    
    // Probar búsqueda lineal
    clock_t inicio = clock();
    int resultado_lineal = busqueda_lineal_ineficiente(arreglo, TAMAÑO, objetivo);
    clock_t fin = clock();
    double tiempo_lineal = medir_tiempo(inicio, fin);
    
    // Probar búsqueda binaria
    inicio = clock();
    int resultado_binario = busqueda_binaria(arreglo, TAMAÑO, objetivo);
    fin = clock();
    double tiempo_binario = medir_tiempo(inicio, fin);
    
    // Mostrar resultados
    printf("Búsqueda del valor %d en arreglo de %d elementos:\n", objetivo, TAMAÑO);
    printf("Búsqueda lineal: índice %d, tiempo %.6f segundos\n", 
           resultado_lineal, tiempo_lineal);
    printf("Búsqueda binaria: índice %d, tiempo %.6f segundos\n", 
           resultado_binario, tiempo_binario);
    
    if (tiempo_lineal > tiempo_binario) {
        printf("La búsqueda binaria fue %.2fx más rápida\n", 
               tiempo_lineal / tiempo_binario);
    }
    
    // Liberar memoria
    free(arreglo);
    
    // Ejemplo de optimización de memoria
    ejemplo_optimizacion_memoria();
    
    return 0;
}
```

### 13.4 Consejos Finales

```c
/*
=== GUÍA RÁPIDA DE REFERENCIA ===

1. DECLARACIÓN DE VARIABLES:
   - Siempre inicializar: int x = 0;
   - Usar nombres descriptivos: int contador_estudiantes;
   - Declarar cerca de su primer uso

2. TIPOS DE DATOS:
   - char: 1 byte, -128 a 127
   - int: 4 bytes (típico), ~±2 mil millones
   - float: 4 bytes, ~7 dígitos de precisión
   - double: 8 bytes, ~15 dígitos de precisión

3. CONSTANTES:
   - #define PI 3.14159 (preprocessing)
   - const int MAX = 100; (compilación)

4. ARREGLOS:
   - int arr[10] = {0}; (inicializar todo a 0)
   - Siempre verificar límites antes del acceso

5. PUNTEROS:
   - int *ptr = &variable;
   - Siempre verificar ptr != NULL antes de usar
   - free() después de malloc()

6. FUNCIONES:
   - Un propósito por función
   - Usar const para parámetros que no se modifican
   - Verificar valores de retorno

7. MEMORIA DINÁMICA:
   - malloc() siempre con verificación de NULL
   - Emparejar cada malloc() con free()
   - Establecer punteros a NULL después de free()

8. DEBUGGING:
   - Usar printf() para trazar valores
   - Compilar con -g para información de debug
   - Usar herramientas como valgrind

9. BUENAS PRÁCTICAS:
   - Código legible es mejor que código "inteligente"
   - Comentar el "por qué", no el "qué"
   - Consistencia en estilo de nomenclatura

10. EVITAR:
    - Variables globales cuando sea posible
    - Números mágicos (usar constantes)
    - Código duplicado
    - Funciones muy largas (>50 líneas)
*/

#include <stdio.h>

int main() {
    printf("=== FIN DE LA GUÍA COMPLETA ===\n");
    printf("Variables y Tipos de Datos en C\n");
    printf("¡Felicitaciones por completar la guía!\n");
    
    printf("\nPróximos pasos recomendados:\n");
    printf("1. Practicar con los ejercicios propuestos\n");
    printf("2. Experimentar con diferentes tipos de datos\n");
    printf("3. Crear programas pequeños aplicando los conceptos\n");
    printf("4. Estudiar estructuras de datos más avanzadas\n");
    printf("5. Aprender sobre algoritmos y optimización\n");
    
    return 0;
}
```

---

## Recursos Adicionales

### Libros Recomendados:
- "The C Programming Language" por Kernighan & Ritchie
- "C: How to Program" por Deitel & Deitel
- "Expert C Programming" por Peter van der Linden

### Herramientas Útiles:
- **Compiladores**: GCC, Clang, Visual Studio
- **IDEs**: Code::Blocks, Dev-C++, Visual Studio Code
- **Debugging**: GDB, Valgrind, Dr. Memory
- **Análisis estático**: Cppcheck, Clang Static Analyzer

### Sitios Web de Referencia:
- cppreference.com
- stackoverflow.com
- github.com (proyectos open source)
- leetcode.com (práctica de algoritmos)

---

*Esta guía proporciona una base sólida para entender y trabajar con variables y tipos de datos en C. La práctica constante y la experimentación son clave para dominar estos conceptos fundamentales.*